<!DOCTYPE html>
<html lang="en">
<head>
    <title>Erfan's Portfolio</title>
    <meta charset="utf-8" name="viewport" content="width=device-width, initial-scale=1">
    <!--Custom and framework Style Sheets-->
    <link rel="stylesheet" type="text/css" href="css/lessons.css">
    <link rel="stylesheet" type="text/css" href="../css/navbar.css">
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <!--Google Fonts CND-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
    <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet">
    <!--animate css-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css">
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=java&amp;skin=sunburst"></script>
</head>
<style>
    .header {
        background-image: url("../images/search.jpg");
        height: 40%;
        opacity: 0.9;
        background-color: black;
        background-repeat: no-repeat;
        background-size: cover;
        position: relative;
        top: 0;
        left: 0;
        z-index: 0;
    }
</style>

<body class="railway-font bgc">
<div class="header">
    <div id="jumbo">
        <h1 class=" display-3 animated fadeInUp display-5">Searching & Sorting</h1>
    </div>
</div>

<nav id="nav" class="navbar fixed-top navbar-expand-sm bgdark navbar-dark scrolling-navbar ">
    <a class="navbar-brand railway-font" href="../index.html"> Erfan Yeganehfar</a>
    <div class="navbar-collapse collapse">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item">
                <a class="nav-link" href="../tutorials/oop1.html">Intro To OOP 1</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../tutorials/arrays.html">Arrays & ArraysLists</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../tutorials/recursion.html">Recursion</a>
            </li>
            <li class="nav-item">
                <a class="nav-link active" href="../tutorials/searching-sorting.html">Searching & Sorting</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../tutorials/oop2.html">Intro To OOP 2</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../tutorials/programming-style.html">Program Design</a>
            </li>
        </ul>
        <ul class="navbar-nav ml-auto">
            <li class="nav-item">
                <span class="menubtn" onclick="openNav()">&#9776;</span>
            </li>
        </ul>
    </div>
</nav>

<div id="myNav" class="overlay-nav">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
    <div class="relative-center">
        <a href="../tutorial-page.html" id="highlight">Tutorial</a>
        <a href="../index.html">Home</a>
        <a href="../about-me.html">About Me</a>
        <a href="../project.html">Projects</a>
    </div>
</div>

<div class="contents m-font">
    <div>
        <h1>Searching</h1>
        <hr/>
        <p>In Java, the premise of searching is to find a value within a data set. There are many ways of doing this,
            yet the most common ones are <strong>Sequential</strong> and <strong>Binary</strong> search. The easiest to
            implement would be sequential as binary requires an already sorted array</p>
        <h4>Sequential Search</h4>
        <p>Sequential search is one of the easier types of searching algorithm. It iterates over a data set from the
            first element to the element where the target is found or the
            end of the array. The best case scenario is when the target is the first element that is checked and the
            worst case is when the target is
            the last slot checked. This algorithm has a time complexity of
            \(\mathcal{O}(n)\).</p>
        <pre>
            <code class="prettyprint" style="background-color: transparent">
            public int seqSearch(int [] arr, int target){
                for (int i = 0; i < arr.length; i++){ //traverse through each element
                    if (val == arr[i]){ // check if current element is the target
                        return i;
                    }
                }
                return -1;
            }
            </code>
        </pre>
        <h4>Binary Search</h4>
        <p>If the elements in a certain data set are already sorted, the <strong>divide-and-conquer</strong> approach to
            searching provides an alternative solution that is more efficient. Since a binary search is a
            divide-and-conquer algorithm, it requires splitting up the data into two part, the right and the left side.
            Based on the value of the target and the middle element's, the left and right sides are shifted until the
            target is in the middle,
            where it is then returned. if the target was not found in either the left or right side,
            then -1 is returned. This algoriyhm has a time complexity of \( \mathcal{O}(n \log n) \)</p>

        <pre>
            <code class="prettyprint" style="background-color: transparent">
            public int binarySearch(int [] arr, int target){
                int left = 0; // left start at index 0
                int right = arr.length - 1; //right start at the end
                while (right-left > 0){
                    int middle = (left + right) / 2; //the calculated middle of the array
                    int midVal = arr[middle];
                    if (target > midVal){ //if the target is greater than the middle value, it means that the value is on the right
                        left = midVal + 1;
                    }
                    else if (target < midVal){//if the target is less than the middle value, it means that the value is on the left
                        right = midVal - 1;
                    }
                    else{
                        return middle;
                    }
                }
                return -1;
            }
            </code>
        </pre>
        <h1>Sorting</h1>
        <hr/>
        <h4>BogoSort</h4>
        <br>
        <div class="row">
            <div class="col-sm-12 text-center">
                <img src="../images/bogo.png" class="rounded" alt="in1">
            </div>
        </div>
        <br>
        <p>This sorting algorithm works by randomly shuffling the array, and then checking to see if it is sorted.
            To shuffle the array, loop through the array from the end to the start, and generate a random number from 0
            to the current index. Then swap the current index with the random number.
            To check if the array is sorted, loop through the array and make sure that each successive number is greater
            or equal to the previous. If the next number is smaller than the previous, the array is not sorted.
            Repeat the process until the array is sorted.
            This sort is not good whatsoever, because it is so slow. Instead, it can be used to demonstrate that it is
            better to use different sorting algorithms, and it can teach people about why bogosort is slow.
        </p>
        <p>Part of the reason why this sorting algorithm is so bad is because the normal implementation is a
            pseudo-non-deterministic one, meaning that there is no upper bounds.
            Meaning that if one permutation of the array is achieved than there is a possibility that it would produce
            the same case again. If the problem was to be implemented deterministically,
            then the worst time complexity would be \(\mathcal{O}(n * n!)\) which is also the average time complexity,
            this is based on the amount of permutations possible before a number can be reached. The best case would be
            if on the first iteration the data is sorted. In a non deterministic solution (since there is no upper
            bounds) the worst case time complexity is \(\mathcal{O}(\infty)\) with the same average time complexity of
            \(\mathcal{O}(n * n!)\).
        </p>
        <pre>
            <code class="prettyprint" style="background-color: transparent">
            import java.util.Arrays;
            //class Bogosort
            public class Bogosort{
             public static void shuffle(int[] arr){
              //loop from the end to the beginning of the array
              for (int i = arr.length - 1; i >= 0; i --){
               //generate a random number from 0 to i
               int random = (int)(Math.random() * (i + 1));
               //swap the number and i
               int temp = arr[i];
               arr[i] = arr[random];
               arr[random] = temp;
              }
             }
             public static boolean isSorted(int[] arr){
              for (int i = 0; i < arr.length - 1; i ++){
               if (arr[i] > arr[i + 1])
                //if the previous element is greater than the next, the array is not sorted
                return false;
              }
              return true;
             }
             public static void bogoSort(int[] arr){
              //prints the initial array
              System.out.println(Arrays.toString(arr));
              //continue as long as the array is not sorted
              while (!isSorted(arr)){

               //shuffle the array
               shuffle(arr);
               //prints the shuffled array
               System.out.println(Arrays.toString(arr));
              }
             }
             public static void main(String[] args){
              int[] arr = {1, 3, 5, 4, 6, 10, 6}
              bogoSort(arr);
             }
            }
            </code>
        </pre>
        <h4>Insertion Sort</h4>
        <p> Insertion sort is a simple sorting algorithm where an array can be sorted in a more linear fashion (than
            bogosort).
            Insertion sort is a better alternative to a sorting algorithm such as bogosort, yet it isn't as effective as
            some other algorithms such as Quick sort or Merge sort.
            a sorted section and an unsorted section, the idea is to move the elements from the unsorted section to the
            sorted one. with each comparision that requires an element to move, the element is inserted into the sorted
            list. Sometimes the elements need to move to make space, so they are shifted to the right. The average case
            time complexity for this algorithm is \( \mathcal{O}(n^2) \) with a best case of \( \mathcal{O}(n)\).</p>
        <pre>
            <code class="prettyprint" style="background-color: transparent">
            public void sort(int[] arr){
             for ( int x = 1; x < arr.length; x++) {
              int key = arr[x]; // current element to be checked
              int j = x; // the current index
              //shifts the array to make room for insertion
              while (j > 0 && arr[j - 1] > key) { //checks to see where the key can be inserted into
               arr[j] = arr[j - 1]; //inserts the key
               j--;
              }
              arr[j] = key; //the key is
             }
            }
            </code>
        </pre>
        <h1>Time Complexity</h1>
        <hr/>
        <p>Time complexity is a topic on its own, yet it is an important topic for sorting/searching algorithm as it
            outlines the amount of time they need to process data.
            Time complexity in its simplest form means the amount of time a computer takes to run a certain algorithm.
            In the comparison chart below, the time complexity for some searching and sorting algorithms are compared to
            each other.</p>
        <table class="table">
            <thead>
            <tr>
                <th>Time Complexity</th>
                <th>Algorithms</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <th>\( \mathcal{O}(1) \)</th>
                <td>traversing on index of an array</td>
            </tr>
            <tr>
                <th>\( \mathcal{O}(\log n) \)</th>
                <td>Binary search and Binary indexed tree</td>
            </tr>
            <tr>
                <th>\( \mathcal{O}(n) \)</th>
                <td>Sequential search</td>
            </tr>
            <tr>
                <th>\( \mathcal{O}(n \log n) \)</th>
                <td>Merge sort, Heap sort, and Quicksort</td>
            </tr>
            <tr>
                <th>\( \mathcal{O}(n^2) \)</th>
                <td>Bubble sort, Selection sort, Insertion sort</td>
            </tr>
            <tr>
                <th>\( \mathcal{O}(n!) \)</th>
                <td>permutations</td>
            </tr>
            <tr>
                <th>\(\mathcal{O}(n * n!)\)</th>
                <td>Average Bogosort</td>
            </tr>
            </tbody>
        </table>
    </div>
</div>

<script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML"></script>
<!--Bootstrap imports-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
<!--navbar js-->
<script src="../js_app/navOptions.js"></script>
</body>
</html>